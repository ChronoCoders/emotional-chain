PHASE 1: HYBRID CONSENSUS MECHANISM (PoE + PoS)Task 1.1: Implement Stake-Based Sybil ProtectionFile: /shared/consensus/hybridConsensus.tsCreate new hybrid consensus that combines PoS economic security with PoE biometric bonuses:typescriptinterface ValidatorStake {
  validatorAddress: string;
  stakedAmount: bigint; // Minimum 10,000 EMO required
  stakeTimestamp: number;
  lockedUntil: number; // Lock period for slashing protection
}

interface ValidatorRequirements {
  minimumStake: bigint; // 10,000 EMO
  emotionalFitnessThreshold: number; // 75% (soft requirement now)
  deviceTrustLevel: 1 | 2 | 3;
}

class HybridConsensus {
  // Validator must have stake AND device, but emotional fitness is bonus/penalty
  async canParticipateInConsensus(validator: Validator): Promise<boolean> {
    const hasMinimumStake = await this.checkStake(validator.address);
    const hasRegisteredDevice = await this.checkDeviceRegistration(validator.address);
    
    // Hard requirements
    if (!hasMinimumStake || !hasRegisteredDevice) {
      return false;
    }
    
    // Emotional fitness now affects rewards, not participation
    return true;
  }
  
  // Reward calculation based on stake + emotional performance
  calculateBlockReward(
    baseReward: bigint,
    emotionalScore: number,
    deviceTrustLevel: 1 | 2 | 3
  ): bigint {
    // Base: 50 EMO
    let reward = baseReward;
    
    // Emotional bonus: -25% to +25%
    const emotionalMultiplier = 0.75 + (emotionalScore / 100) * 0.5;
    reward = BigInt(Math.floor(Number(reward) * emotionalMultiplier));
    
    // Device trust bonus
    const deviceMultipliers = { 1: 0.5, 2: 1.0, 3: 1.5 };
    reward = BigInt(Math.floor(Number(reward) * deviceMultipliers[deviceTrustLevel]));
    
    return reward;
  }
}Database Schema Update:Add to /shared/schema.ts:typescriptexport const validatorStakes = pgTable('validator_stakes', {
  id: serial('id').primaryKey(),
  validatorAddress: text('validator_address').notNull().unique(),
  stakedAmount: text('staked_amount').notNull(), // Store as string for bigint
  stakeTimestamp: timestamp('stake_timestamp').notNull(),
  lockedUntil: timestamp('locked_until').notNull(),
  slashingEvents: integer('slashing_events').default(0),
  totalSlashed: text('total_slashed').default('0'),
});Action Items:

 Create hybridConsensus.ts with stake validation logic
 Update validators table to include deviceTrustLevel column
 Implement stakeTokens() and unstakeTokens() functions with lock periods
 Update block reward calculation to use hybrid formula
 Add slashing mechanism for validators who go offline (not for stress)
Task 1.2: Three-Tier Device Attestation SystemFile: /shared/biometric/deviceAttestation.tsImplement progressive trust levels for different device types:typescriptinterface DeviceRegistration {
  deviceId: string;
  deviceType: 'commodity' | 'medical' | 'hsm'; // Level 1, 2, 3
  manufacturer: string;
  serialNumber?: string; // Level 2+
  attestationProof?: string; // Level 3 only
  trustLevel: 1 | 2 | 3;
  registeredAt: number;
  validatorAddress: string;
}

class DeviceAttestationService {
  // Level 1: OAuth with manufacturer API
  async registerCommodityDevice(
    validatorAddress: string,
    oauthToken: string,
    provider: 'fitbit' | 'apple' | 'garmin'
  ): Promise<DeviceRegistration> {
    // Verify OAuth token with provider
    const deviceInfo = await this.verifyWithProvider(provider, oauthToken);
    
    return {
      deviceId: deviceInfo.id,
      deviceType: 'commodity',
      manufacturer: provider,
      trustLevel: 1,
      validatorAddress,
      registeredAt: Date.now(),
    };
  }
  
  // Level 2: Direct USB/Bluetooth with serial verification
  async registerMedicalDevice(
    validatorAddress: string,
    serialNumber: string,
    deviceModel: 'polar_h10' | 'muse_s' | 'empatica_e4'
  ): Promise<DeviceRegistration> {
    // Check serial number against manufacturer database
    const isValid = await this.verifySerialNumber(deviceModel, serialNumber);
    
    if (!isValid) {
      throw new Error('Invalid serial number');
    }
    
    return {
      deviceId: `${deviceModel}_${serialNumber}`,
      deviceType: 'medical',
      manufacturer: deviceModel,
      serialNumber,
      trustLevel: 2,
      validatorAddress,
      registeredAt: Date.now(),
    };
  }
  
  // Level 3: Hardware Security Module with cryptographic attestation
  async registerHSMDevice(
    validatorAddress: string,
    attestationProof: string // Signed by device's private key
  ): Promise<DeviceRegistration> {
    // Verify cryptographic signature from TPM/Secure Enclave
    const isValid = await this.verifyAttestationProof(attestationProof);
    
    if (!isValid) {
      throw new Error('Invalid attestation proof');
    }
    
    return {
      deviceId: extractDeviceId(attestationProof),
      deviceType: 'hsm',
      manufacturer: 'certified_hsm',
      attestationProof,
      trustLevel: 3,
      validatorAddress,
      registeredAt: Date.now(),
    };
  }
}Database Schema:typescriptexport const deviceRegistrations = pgTable('device_registrations', {
  id: serial('id').primaryKey(),
  deviceId: text('device_id').notNull().unique(),
  deviceType: text('device_type').notNull(), // 'commodity' | 'medical' | 'hsm'
  manufacturer: text('manufacturer').notNull(),
  serialNumber: text('serial_number'),
  attestationProof: text('attestation_proof'),
  trustLevel: integer('trust_level').notNull(), // 1, 2, or 3
  validatorAddress: text('validator_address').notNull(),
  registeredAt: timestamp('registered_at').notNull(),
  lastActivityAt: timestamp('last_activity_at'),
  isActive: boolean('is_active').default(true),
});Action Items:

 Create deviceAttestation.ts service
 Implement OAuth integration for Fitbit/Apple Health (Level 1)
 Add serial number verification API endpoints (Level 2)
 Create attestation proof verification logic (Level 3 - can be placeholder)
 Add device registration endpoints to API
 Update validator dashboard to show device trust level