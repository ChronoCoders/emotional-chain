PHASE 2: PRIVACY-PRESERVING ZK PROOFS
Task 2.1: Threshold Proof System (Periodic Instead of Real-Time)
File: /shared/zk/thresholdProofs.ts
Replace continuous biometric streaming with periodic threshold proofs:
typescriptinterface EmotionalThresholdProof {
  validatorAddress: string;
  timestamp: number;
  proofData: string; // ZK proof that score > threshold
  commitment: string; // Hash commitment to hide actual score
  isValid: boolean;
  scoreAboveThreshold: boolean; // Only reveals boolean, not value
}

class ThresholdProofSystem {
  // Client-side computation (runs on validator's machine)
  async generateThresholdProof(
    biometricData: BiometricData,
    threshold: number = 75
  ): Promise<EmotionalThresholdProof> {
    // Calculate score locally
    const score = this.computeEmotionalScore(biometricData);
    
    // Generate random nonce for privacy
    const nonce = crypto.randomBytes(32);
    
    // Create commitment
    const commitment = this.hash(score.toString() + nonce.toString('hex'));
    
    // Generate ZK proof (using simplified approach for now)
    // TODO: Replace with actual Circom circuit when ready
    const proofData = await this.generateProof({
      privateInputs: { score, nonce },
      publicInputs: { threshold, commitment },
      statement: 'score > threshold',
    });
    
    return {
      validatorAddress: this.validatorAddress,
      timestamp: Date.now(),
      proofData,
      commitment,
      isValid: true,
      scoreAboveThreshold: score > threshold,
    };
  }
  
  // Network-side verification (runs on other validators)
  async verifyThresholdProof(proof: EmotionalThresholdProof): Promise<boolean> {
    // Verify ZK proof without learning actual score
    const isProofValid = await this.verifyProof(proof.proofData, {
      publicInputs: { threshold: 75, commitment: proof.commitment },
    });
    
    // Check timing (prevent replay attacks)
    const currentTime = Date.now();
    const proofAge = currentTime - proof.timestamp;
    
    // Proof must be recent (within 15 minutes)
    if (proofAge > 15 * 60 * 1000) {
      return false;
    }
    
    return isProofValid;
  }
  
  // Submit proof every 10 minutes instead of continuous stream
  async submitPeriodicProof(): Promise<void> {
    setInterval(async () => {
      const biometricData = await this.collectBiometricData();
      const proof = await this.generateThresholdProof(biometricData, 75);
      
      // Add random jitter (0-60 seconds) to prevent timing analysis
      const jitter = Math.random() * 60 * 1000;
      await sleep(jitter);
      
      await this.broadcastProof(proof);
    }, 10 * 60 * 1000); // Every 10 minutes
  }
}
Circom Circuit (create /circuits/emotionalThreshold.circom):
circompragma circom 2.0.0;

include "circomlib/comparators.circom";
include "circomlib/poseidon.circom";

template EmotionalThreshold() {
    // Private inputs (not revealed)
    signal input score;
    signal input nonce;
    
    // Public inputs
    signal input threshold;
    signal input commitment;
    
    // Output
    signal output isValid;
    
    // Verify commitment matches
    component hasher = Poseidon(2);
    hasher.inputs[0] <== score;
    hasher.inputs[1] <== nonce;
    commitment === hasher.out;
    
    // Verify score > threshold
    component comp = GreaterThan(8); // 8-bit comparison
    comp.in[0] <== score;
    comp.in[1] <== threshold;
    
    isValid <== comp.out;
}

component main {public [threshold, commitment]} = EmotionalThreshold();
Action Items:

 Create thresholdProofs.ts with proof generation/verification
 Install Circom and SnarkJS: npm install circomlib snarkjs
 Compile Circom circuit and generate proving/verification keys
 Update consensus to accept proofs every 10 minutes (not real-time)
 Add random timing jitter to prevent correlation attacks
 Store only commitments in database, never raw scores