PHASE 3: GDPR COMPLIANCE
Task 3.1: On-Device Score Computation (Data Minimization)
File: /client/services/biometricProcessor.ts
All biometric processing happens client-side, only commitments go to blockchain:
typescriptclass BiometricProcessor {
  // Runs entirely in browser/validator node - no raw data sent
  async processLocalBiometricData(rawData: RawBiometricData): Promise<ScoreCommitment> {
    // 1. Compute score locally
    const score = this.computeEmotionalScore({
      heartRate: rawData.hr,
      hrv: rawData.hrv,
      stressLevel: rawData.stress,
      coherence: this.calculateCoherence(rawData),
    });
    
    // 2. Generate commitment
    const nonce = crypto.randomBytes(32);
    const commitment = keccak256(
      Buffer.concat([
        Buffer.from(score.toString()),
        nonce,
      ])
    );
    
    // 3. Create ZK proof (score > threshold)
    const proof = await this.generateThresholdProof(score, 75, nonce);
    
    // 4. Return ONLY commitment and proof (NOT raw data or score)
    return {
      commitment: commitment.toString('hex'),
      proof: proof.toString('hex'),
      timestamp: Date.now(),
    };
  }
  
  // RAW DATA NEVER LEAVES THIS FUNCTION
  private async getRawBiometricData(): Promise<RawBiometricData> {
    // Data stays in memory, never persisted
    const data = await this.deviceConnection.readCurrent();
    return data;
  }
}
Update /shared/schema.ts:
typescript// REMOVE raw biometric storage
// DELETE this table entirely:
// export const biometricReadings = pgTable(...)

// ONLY store commitments
export const biometricCommitments = pgTable('biometric_commitments', {
  id: serial('id').primaryKey(),
  validatorAddress: text('validator_address').notNull(),
  commitment: text('commitment').notNull(), // Hash only
  zkProof: text('zk_proof').notNull(),
  timestamp: timestamp('timestamp').notNull(),
  blockHeight: integer('block_height'),
});
Action Items:

 Move ALL biometric computation to client-side
 Delete biometricReadings table (GDPR violation)
 Create biometricCommitments table
 Ensure no raw data ever sent over network
 Add client-side encryption for local storage if needed


Task 3.2: Right to Erasure Implementation
File: /server/routes/gdpr.ts
Implement proper data deletion while preserving blockchain integrity:
typescriptinterface GDPRErasureRequest {
  validatorAddress: string;
  requestType: 'full' | 'personal_only';
  signature: string; // Prove ownership of address
}

class GDPRComplianceService {
  async handleErasureRequest(request: GDPRErasureRequest): Promise<void> {
    // Verify signature (user must prove they own the address)
    const isValid = await this.verifySignature(request);
    if (!isValid) throw new Error('Invalid signature');
    
    // What CAN be deleted (off-chain personal data)
    await db.delete(offChainProfiles)
      .where(eq(offChainProfiles.validatorAddress, request.validatorAddress));
    
    await db.delete(deviceRegistrations)
      .where(eq(deviceRegistrations.validatorAddress, request.validatorAddress));
    
    // What CANNOT be deleted (blockchain integrity)
    // - Block hashes (immutable)
    // - Transaction records (immutable)
    // - Commitments (meaningless without nonce anyway)
    
    // But we can anonymize:
    await db.update(validators)
      .set({ 
        email: '[REDACTED]',
        name: '[REDACTED]',
        // Keep address for blockchain integrity
      })
      .where(eq(validators.address, request.validatorAddress));
  }
}
Create /shared/schema.ts separation:
typescript// ON-CHAIN DATA (cannot be deleted)
export const blocks = pgTable('blocks', { /* ... */ });
export const transactions = pgTable('transactions', { /* ... */ });
export const biometricCommitments = pgTable('biometric_commitments', { /* ... */ });

// OFF-CHAIN DATA (can be deleted for GDPR)
export const offChainProfiles = pgTable('off_chain_profiles', {
  id: serial('id').primaryKey(),
  validatorAddress: text('validator_address').notNull().unique(),
  email: text('email'),
  name: text('name'),
  kycDocuments: text('kyc_documents'), // Encrypted file paths
  consentTimestamp: timestamp('consent_timestamp').notNull(),
  consentVersion: text('consent_version').notNull(),
});
Action Items:

 Create clear separation: on-chain vs off-chain data
 Implement erasure endpoint: POST /api/gdpr/erasure
 Add signature verification for erasure requests
 Create GDPR dashboard showing what data exists
 Add consent management system


Task 3.3: Explicit Consent Smart Contract
File: /contracts/ConsentManagement.sol
Create on-chain consent record:
solidity// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BiometricConsent {
    struct Consent {
        address validator;
        uint256 timestamp;
        string consentVersion; // "v1.0"
        bool isActive;
    }
    
    mapping(address => Consent) public consents;
    
    event ConsentGiven(address indexed validator, string version, uint256 timestamp);
    event ConsentRevoked(address indexed validator, uint256 timestamp);
    
    function giveConsent(string memory version) external {
        consents[msg.sender] = Consent({
            validator: msg.sender,
            timestamp: block.timestamp,
            consentVersion: version,
            isActive: true
        });
        
        emit ConsentGiven(msg.sender, version, block.timestamp);
    }
    
    function revokeConsent() external {
        require(consents[msg.sender].isActive, "No active consent");
        consents[msg.sender].isActive = false;
        
        emit ConsentRevoked(msg.sender, block.timestamp);
    }
    
    function hasValidConsent(address validator) external view returns (bool) {
        return consents[validator].isActive;
    }
}
Action Items:

 Create consent smart contract
 Deploy to testnet
 Add consent check before allowing validator registration
 Create UI for consent management
 Add consent revocation = automatic unstaking